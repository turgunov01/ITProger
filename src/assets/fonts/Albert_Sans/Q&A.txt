3. Самое важное в JavaScript
4. Что такое console.log
5. Выражения
6. Переменные
7. Объявление переменных
8. Практика по созданию переменных
9. Примитивные типы
10. Ссылочный тип
11. Динамическая типизация
12. Объекты
13. Создание и удаление свойств объектов
14. Вложенные свойства
15. Сокращенный формат записи свойств
16. Глобальные объекты
17. Методы объекта
18. JSON - JavaScript Object Notation
19. Мутация в JavaScript
20. Как избежать мутаций объектов
21. Что такое функция
22. Объявление и вызов функции
23. Передача значения по ссылке
24. Колбэк функции
25. Правила работы с функциями
26. Области видимости
27. Цепочка областей видимости
28. Жизненный цикл переменных
29. Типы областей видимости
30. Строгий режим
31. Операторы
32. Оператор присваивания
33. Унарные и бинарные операторы
34. Форматы записи операторов
35. Приоритетность операторов
36. Логические операторы
37. Ложные значения
38. Практика с typeof оператором
39. Оператор НЕ
40. Оператор короткого замыкания И
41. Оператор короткого замыкания ИЛИ
42. Трюк с оператором И и вызовом функции
43. Цепочки выражений с операторами И и ИЛИ
44. Оператор разделения объекта на свойства
45. Конкатенация строк
46. Функциональные выражения
47. Стрелочные функции
48. Значения параметров функции по умолчанию
49. Обработка ошибок
50. Инструкции
51. Выражения-инструкции
52. Как отличить инструкцию от выражения
53. Массивы
54. Оператор сравнения для массивов и объектов
55. Массив против Объекта
<!-- 56. Как работать с элементами массива -->
<!-- 57. Методы массивов -->
58. Метод forEach
59. Метод map
60. Деструктуризация объектов
61. Деструктуризация массивов
62. Деструктуризация параметров функции
<!-- 63. Условные инструкции -->
<!-- 64. Условная инструкция if else
65. Условная инструкция if else if
66. Использование if в функциях
67. Инструкция switch
68. Тернарный оператор -->
<!-- 69. Циклы3 -->
70. Цикл for
72. Цикл while
73. Цикл do while
74. Цикл for in
75. Методы keys и values для объектов
76. Цикл for in для массивов
77. Цикл for of
78. Модули
79. Создание и запуск модулей с помощью Node
80. Несколько экспортов
81. Правила работы с модулями
<!-- 82. Практика по созданию нескольких экспортов -->
<!-- 83. Как используются модули в React -->
84. Введение в классы и прототипы
85. Пример класса
86. Создание экземпляров класса
<!-- 87. Цепочка прототипов -->
88. Проверка принадлежности классу
89. Вызов унаследованных методов
<!-- 90. Практика по созданию классов и экземпляров -->
91. Проверка принадлежности свойств объектов
92. Создание нескольких экземпляров
93. Статические методы
<!-- 94. Практика по созданию статических методов -->
95. Расширение других классов
96. Что же такое прототип
<!-- 97. Строки и числа ведут себя как объекты -->
98. Введение в промисы
99. Создание и использование промисов
100. Использование промисов в fetch
<!-- 101. Практика по использованию промисов и fetch -->
<!-- 102. Практика с отклонением промисов -->
103. Вызов fetch внутри промиса
104. Асинхронные функции
105. Использование await внутри асинхронных функций
<!-- 106. Пример с async await -->
<!-- 107. Переход с промисов на async await -->
108. Обработка ошибок в асинхронных функциях
109. Ключевые принципы в async await

// Answers

3. Самое важное в Яваскрипте это объекты, функции и выражение
4. Это базовой метод самого Яваскрипта, она показывает вызванные методы или объекты к примеру в консоле
5. Выражение - это принятая значение
6. Переменные держут в себе какое-то значение
7. Их можно объявлять с помощью ключовых слов такие как const, let, var
9. Есть разные варианты примитывных типов такие как:
- string
- integer(number)
- boolean
- symbol
10. Есть два типа ссылочных типов - это точечная и скобочная запись
11. Для типизации объектов используется typeof
12. Внутри объекта есть ключ и значение
13. Объекты создаются с помощью new Object() и можно удалить с помощью delete
15. При вызове не существующего ключа с объекта создается новый ключ в объекте
16. Глобальные объекты это window, global(nodejs), globalWindow
17. Есть разные методы объекта. Object.keys()/ Object.create() / Object.assign(arr, {})
18. С помощью JSON методов можно превратить объекты на стринг вариант
19-20. Чтобы избежать мутации объектов нужно использовать методы объекты такие как assign() чтобы оригинальная версия не поменялась
21. Это объекты которые позволять менять логику или же обрабатывать данные
22. Функции можно вызивать двумя способами 1. с помощью ключевого слова function или же с стрелочным вариантом в переменной как const myFn = () => {}
23. Передача происходит с помощью переменных
24. Это происходит с помощью двух функции первая будет для колбека а вторая вызывающая той функции внутри себя
25. Функции должна названа смотря на неё задачу, она должна иметь только одну задачу и после этого не должна менять внешные переменные
26. Областями видимости бывают глобалными и внутренными точнее видимость внутри функции
28. Переменные будут иметь значение undefined до того как они будет содержат в себе какую нибудь значение
29. Типы областями можно называть две места в коде самое главное это глобальное и второй внутри функции или объектов
30. При строгом режиме не объявленные переменные не могут быть использованы
31. +, -, *, /, ==, ===, =, =>, <, >, <=, >=
32. =, =>
33. Унарные это - ++, --, Бинарные это - &&, ||,
34. Есть точечная запись и скобочная запись
obj.value, obj['value'], obj.key['value']
36. if, if...else, if...else if...else
37. false, undefined, 0
38. typeof проверяет тип объекта или выражение
39. !
40. &&
41. ||
45. Можно с помощью оператора +, или же с помощью ${} внутри `` если для объектов то это с помощью метода concat()
46. После создание функции его можно сохранит внутри переменной для быстрого доступа к нему по моему
47. Она пишется c помощью стрелок и скобок для аргументов и в нём не пишется ключевое слово function
49. try...catch(error)
50. Инструкция это команда для выполнения что-то
51. Выражение инструкция это код после выполнение вернет что то в результате
52. Инструкция это команда действия, команда, а выражение это блок кода
53. Массивы требуют коллекцию упорядочных данных, а объекты предоставляют коллекции
54. ==
55. Методы массивов - функции высшего порядка в массиве
- push() - Добавляет элемент в конце массива
const array = [1,2,3]
array.push(4) // [1,2,3,4]

- pop() - Удаляет с конца списки массива
const array = [1,2,3]
array.push(4) // [1,2]

- unshift/shift() - Добавляет/Удаляет элемента в начале списка массива
const array = [1,2,3]
array.unshift(true) // [true,1,2,3]
array.shift(4) // [2,3,4]

- forEach() - Метод обращающийся каждому элементу/значению массива по одному
const array = [1,2,3,4]
array.forEach(el => (el * 2)) // 2,4,6,8

- map() - Такой же метод как forEach, но она возвращает новый массив при результате
const array = [1,2,3,4]
array.forEach(el => (el * 2)) // [2,4,6,8]

- slice() - При усваивание индексов началы и конца элементов она будет начинаться и заканчиваться на том индексе в котором она показано
const array = [1,2,3,4,5,6,7,8,9,0]
array.slice(1, 4) // [2,3,4,5] - Начинается с индекса 1 с значением = 2. Заканчивается на индексе с значением = 5. Остальные удаляются

- splice() - Удаляет элементов начиная с индекса которая была написана внутри метода и будет удалять или заменить значение удаленного или выбранного элемента
const array = [1,2,3,4,5,6,7,8,9,0]
array.splice(1, 4) // [1,6,7,8,9,0] - 4 значение удалятся начиная от индекса 1, но при этом остальные числа остаются
array.splice(4, 1, 'hello') // [1,2,3,4,'hello',6,7,8,9,0] // Значение который имеет индекс равен = 4 меняется на значение = hello
array.splice(5, 2, 'Hello', 'Why?') // [1,2,3,4,5,'hello','why',8,9,0] // Если нету элемента после значение с индексом 5 то она будет добавлять если нет замены то она будет удалять

58. Метод входит в свойства каждого элемента и может поменять его же свойтсво или добавить новый (манипулировать)
59. Метод map создает новый массив объектов точнее копирует существующий чтобы оригинальная не поменялась
60. Деструктизация массивов - это когда данные массива сохраняются к другому переменному или массиву не вызывая все ключа массива
61. Деструктуризацию можно использовать и с объектами. При этом мы указываем, какие свойства в какие переменные должны вызыватся.
62. При дест. параметра функции, функцию можно использовать многократноъ
63. for, forin, forof, hile, do...while,
70. for() - для обращение каждому элементу отдельно
72. Цикл while() - бесконечный цикл
73. do...while - будет делать или выполнять код до того как условие не сделается
75. Когда есть объект с коллекцией Object.keys((objectName)) вернет все ключи а Object.values((objectName)) вернёт все значение ключей
76. for in() - похоже на функцию forEach
77. for of() - Выполняет цикл обхода по каждым значениям объекта
78. Модули - это импорт и экспорт данных с файла на другой файл. Если она не работает нужно установить package.json (npm init -y)
79. Для этого нужно просто запустить node и вызвать тот файл в котором сделаны все импорты так как: node file.js или file.mjs
80. Экспортировать можно только один по дефалту или массивну. Пример: export {import1, import2, import3} / export default importDefault
81. При импорте одной функции имя функции в оригинале и при импорте не нужно совпадать друг к другу если их много сразу с одного файла они должны переименоваваться или совпадать к оригиналу. Они переименоваваются с помощью *as
84. При создании класса всегда нужно использовать ключевое слово - class
85. Прототипы - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга.
86. В этом случаи new считается оператором создание нового класса исходя из существующего
88. Чтобы проверить нужно использовать instanceof и оа тоже считается оператором проверяющий принадлежность объекта
89. С помощью унаследование можно вызывать ключей находящийся в другом объекте
91. hasOwnProperty() - с помощью него можно узнать принадлежность объекту
93. С помощью статических методов можно объеденить два текста в одну
95. При помощи extends можно создать или расшырять новые или другие массивы
96. Прототипы - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга
98. Объект Promise используется для отложенных и асинхронных вычислений и они создают задержку при возвращение
99. Создать можно с помощью оператора new и название класса Promise
100. JavaScript может отправлять сетевые запросы на сервер и подгружать новую информацию по мере необходимости с помощью fetch
104. Асинхронные функции создают задержку при возвращении ответа или результата с функции, поэтому можно сделать так чтобы при ожидание асинхронный функции другая функция работала
105. await нельзя использовать внутри обычных функциях, await так и работает внутри асинхронных функций ожидая выполнение условии одной функции
108. С помощью .then...catch(error) можно ловить ошибки как try...catch(error) и обрабатывать их
109.

console - Это объект который служит для откладки данных в веб-браузуре
console.log() - Выводит всё в консоль
Самое важное в Жаваскрипт это выражение, объект и функции

Выражения в JavaScript представляют собой комбинации операндов и операторов.
Объект — это набор свойств, и каждое свойство состоит из имени и значения, ассоциированного с этим именем. Функция в JavaScript специальный тип объектов, позволяющий формализовать средствами языка определённую логику поведения и обработки данных.
Массивы представляют коллекции упорядоченных данных, а объекты представляют коллекции, которые не требуют данных.
Классы в JavaScript были введены в ECMAScript 2015 и представляют собой синтаксический сахар над существующим в JavaScript механизмом прототипного наследования. Синтаксис классов не вводит новую объектно-ориентированную модель, а предоставляет более простой и понятный способ создания объектов и организации наследования.

Переменная — именованная часть памяти, в которую могут помещаться разные значения переменной

Есть 6 примитивных типов: string , number , boolean , symbol , null , undefined.

Ссылочный тип – это внутренний тип языка. Чтение свойства, например, с точкой .

Динами́ческая типиза́ция — приём, используемый в языках программирования и языках спецификации, при котором переменная связывается с типом в момент присваивания значения, а не в момент объявления переменной.

Создаются с помощью квадратных скобок и удаляются с помощью ключевого слово delete

Значением свойства объекта может быть всё, что угодно, включая другой объект или массив

Глобальный объект - это объект, который всегда существует в глобальной области видимости. В JavaScript всегда определён глобальный объект. В веб-браузере, когда скрипты создают глобальные переменные, они создаются как свойства глобального объекта.

Array.pop() - Удаляет последний элемент
Array.push() - Добавляет концу массива элемент
Array.reduce() - применяет функцию reducer к каждому элементу массива, возвращая одно результирующее значение. w
Array.shift() - Удаляет первый элемент
Array.slice() - возвращает новый массив, содержащий копию части исходного массива.
Array.some() - проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции
Array.sort() - сортирует элементы массива и возвращает отсортированный массив.
Array.splice() - изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.
Array.toString() - Превращает число на стринг
Array.unshift() - добавляет один или более элементов в начало массива и возвращает новую длину массива.
Array.values() - возвращает новый объект итератора массива Array Iterator, содержащий значения для каждого индекса в массиве.

Обозначение объектов JavaScript (JSON - JavaScript Object Notation) - стандартный текстовый формат для представления структурированных данных на основе синтаксиса объекта JavaScript.

Мутация в JavaScript – это изменение объекта или массива без создания новой переменной и переприсваивания значения.

22. Объявление функции (function definition, или function declaration, или function statement) состоит из ключевого слова function и следующих частей:
Имя функции.
Список параметров (принимаемых функцией) заключённых в круглые скобки () и разделённых запятыми.
Инструкции, которые будут выполнены после вызова функции, заключают в фигурные скобки { }.

23. Строки, числа, логические значения передаются в функцию по значению. Иными словами при передаче значения в функцию, эта функция получает копию данного значения.

24. Простыми словами: коллбэк — это функция, которая должна быть выполнена после того, как другая функция завершила выполнение

25. Имя функции должна быть названа смотря на задачу функции, функции должна выполнять одну задачу

26.
