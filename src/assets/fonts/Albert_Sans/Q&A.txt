Практика по созданию классов и экземпляров -->
Проверка принадлежности свойств объектов
Создание нескольких экземпляров
Статические методы
Практика по созданию статических методов -->
Расширение других классов
Что же такое прототип
Строки и числа ведут себя как объекты -->
Введение в промисы
Создание и использование промисов
. Использование промисов в fetch
Практика по использованию промисов и fetch -->
Практика с отклонением промисов -->
. Вызов fetch внутри промиса
. Асинхронные функции
. Использование await внутри асинхронных функций
- 106. Пример с async await -->
- 107. Переход с промисов на async await -->
. Обработка ошибок в асинхронных функциях
. Ключевые принципы в async await

// Answers

3. Самое важное в Яваскрипте это объекты, функции и выражение
4. Это базовой метод самого Яваскрипта, она показывает вызванные методы или объекты к примеру в консоле
5. Выражение - это принятая значение
6. Переменные держут в себе какое-то значение
7. Их можно объявлять с помощью ключовых слов такие как const, let, var
9. Есть разные варианты примитывных типов такие как:
- string
- integer(number)
- boolean
- symbol
10. Есть два типа ссылочных типов - это точечная и скобочная запись
11. Для типизации объектов используется typeof
12. Внутри объекта есть ключ и значение
13. Объекты создаются с помощью new Object() и можно удалить с помощью delete
15. При вызове не существующего ключа с объекта создается новый ключ в объекте
16. Глобальные объекты это window, global(nodejs), globalWindow
17. Есть разные методы объекта. Object.keys()/ Object.create() / Object.assign(arr, {})
18. С помощью JSON методов можно превратить объекты на стринг вариант
19-20. Чтобы избежать мутации объектов нужно использовать методы объекты такие как assign() чтобы оригинальная версия не поменялась
21. Это объекты которые позволять менять логику или же обрабатывать данные
22. Функции можно вызивать двумя способами 1. с помощью ключевого слова function или же с стрелочным вариантом в переменной как const myFn = () => {}
23. Передача происходит с помощью переменных
24. Это происходит с помощью двух функции первая будет для колбека а вторая вызывающая той функции внутри себя
25. Функции должна названа смотря на неё задачу, она должна иметь только одну задачу и после этого не должна менять внешные переменные
26. Областями видимости бывают глобалными и внутренными точнее видимость внутри функции
28. Переменные будут иметь значение undefined до того как они будет содержат в себе какую нибудь значение
29. Типы областями можно называть две места в коде самое главное это глобальное и второй внутри функции или объектов
30. При строгом режиме не объявленные переменные не могут быть использованы
31. +, -, *, /, ==, ===, =, =>, <, >, <=, >=
32. =, =>
33. Унарные это - ++, --, Бинарные это - &&, ||,
34. Есть точечная запись и скобочная запись
obj.value, obj['value'], obj.key['value']
36. if, if...else, if...else if...else
37. false, undefined, 0
38. typeof проверяет тип объекта или выражение
39. !
40. &&
41. ||
45. Можно с помощью оператора +, или же с помощью ${} внутри `` если для объектов то это с помощью метода concat()
46. После создание функции его можно сохранит внутри переменной для быстрого доступа к нему по моему
47. Она пишется c помощью стрелок и скобок для аргументов и в нём не пишется ключевое слово function
49. try...catch(error)
50. Инструкция это команда для выполнения что-то
51. Выражение инструкция это код после выполнение вернет что то в результате
52. Инструкция это команда действия, команда, а выражение это блок кода
53. Массивы требуют коллекцию упорядочных данных, а объекты предоставляют коллекции
54. ==
55. Методы массивов - функции высшего порядка в массиве
- push() - Добавляет элемент в конце массива
const array = [1,2,3]
array.push(4) // [1,2,3,4]

- pop() - Удаляет с конца списки массива
const array = [1,2,3]
array.push(4) // [1,2]

- unshift/shift() - Добавляет/Удаляет элемента в начале списка массива
const array = [1,2,3]
array.unshift(true) // [true,1,2,3]
array.shift(4) // [2,3,4]

- forEach() - Метод обращающийся каждому элементу/значению массива по одному
const array = [1,2,3,4]
array.forEach(el => (el * 2)) // 2,4,6,8

- map() - Такой же метод как forEach, но она возвращает новый массив при результате
const array = [1,2,3,4]
array.forEach(el => (el * 2)) // [2,4,6,8]

- slice() - При усваивание индексов началы и конца элементов она будет начинаться и заканчиваться на том индексе в котором она показано
const array = [1,2,3,4,5,6,7,8,9,0]
array.slice(1, 4) // [2,3,4,5] - Начинается с индекса 1 с значением = 2. Заканчивается на индексе с значением = 5. Остальные удаляются

- splice() - Удаляет элементов начиная с индекса которая была написана внутри метода и будет удалять или заменить значение удаленного или выбранного элемента
const array = [1,2,3,4,5,6,7,8,9,0]
array.splice(1, 4) // [1,6,7,8,9,0] - 4 значение удалятся начиная от индекса 1, но при этом остальные числа остаются
array.splice(4, 1, 'hello') // [1,2,3,4,'hello',6,7,8,9,0] // Значение который имеет индекс равен = 4 меняется на значение = hello
array.splice(5, 2, 'Hello', 'Why?') // [1,2,3,4,5,'hello','why',8,9,0] // Если нету элемента после значение с индексом 5 то она будет добавлять если нет замены то она будет удалять

58. Метод входит в свойства каждого элемента и может поменять его же свойтсво или добавить новый (манипулировать)
59. Метод map создает новый массив объектов точнее копирует существующий чтобы оригинальная не поменялась
60. Деструктизация массивов - это когда данные массива сохраняются к другому переменному или массиву не вызывая все ключа массива
61. Деструктуризацию можно использовать и с объектами. При этом мы указываем, какие свойства в какие переменные должны вызыватся.
62. При дест. параметра функции, функцию можно использовать многократноъ
63. for, forin, forof, hile, do...while,
70. for() - для обращение каждому элементу отдельно
72. Цикл while() - бесконечный цикл
73. do...while - будет делать или выполнять код до того как условие не сделается
75. Когда есть объект с коллекцией Object.keys((objectName)) вернет все ключи а Object.values((objectName)) вернёт все значение ключей
76. for in() - похоже на функцию forEach
77. for of() - Выполняет цикл обхода по каждым значениям объекта
78. Модули - это импорт и экспорт данных с файла на другой файл. Если она не работает нужно установить package.json (npm init -y)
79. Для этого нужно просто запустить node и вызвать тот файл в котором сделаны все импорты так как: node file.js или file.mjs
80. Экспортировать можно только один по дефалту или массивну. Пример: export {import1, import2, import3} / export default importDefault
81. При импорте одной функции имя функции в оригинале и при импорте не нужно совпадать друг к другу если их много сразу с одного файла они должны переименоваваться или совпадать к оригиналу. Они переименоваваются с помощью *as
84. При создании класса всегда нужно использовать ключевое слово - class
85. Прототипы - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга.
86. В этом случаи new считается оператором создание нового класса исходя из существующего
88. Чтобы проверить нужно использовать instanceof и оа тоже считается оператором проверяющий принадлежность объекта
89. С помощью унаследование можно вызывать ключей находящийся в другом объекте
91. hasOwnProperty() - с помощью него можно узнать принадлежность объекту
93. С помощью статических методов можно объеденить два текста в одну
95. При помощи extends можно создать или расшырять новые или другие массивы
96. Прототипы - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга
98. Объект Promise используется для отложенных и асинхронных вычислений и они создают задержку при возвращение
99. Создать можно с помощью оператора new и название класса Promise
100. JavaScript может отправлять сетевые запросы на сервер и подгружать новую информацию по мере необходимости с помощью fetch
104. Асинхронные функции создают задержку при возвращении ответа или результата с функции, поэтому можно сделать так чтобы при ожидание асинхронный функции другая функция работала
105. await нельзя использовать внутри обычных функциях, await так и работает внутри асинхронных функций ожидая выполнение условии одной функции
108. С помощью .then...catch(error) можно ловить ошибки как try...catch(error) и обрабатывать их

console - Это объект который служит для откладки данных в веб-браузуре
console.log() - Выводит всё в консоль
Самое важное в Жаваскрипт это выражение, объект и функции

Выражения в JavaScript представляют собой комбинации операндов и операторов.
Объект — это набор свойств, и каждое свойство состоит из имени и значения, ассоциированного с этим именем. Функция в JavaScript специальный тип объектов, позволяющий формализовать средствами языка определённую логику поведения и обработки данных.
Массивы представляют коллекции упорядоченных данных, а объекты представляют коллекции, которые не требуют данных.
Массив (Array) в JavaScript является глобальным объектом, который используется для создания массивов                                                                                                                                                                                                                                                                                                                                                                                                            ; которые представляют собой высокоуровневые спископодобные объекты.
Классы в JavaScript были введены в ECMAScript 2015 и представляют собой синтаксический сахар над существующим в JavaScript механизмом прототипного наследования. Синтаксис классов не вводит новую объектно-ориентированную модель, а предоставляет более простой и понятный способ создания объектов и организации наследования.

Переменная — именованная часть памяти, в которую могут помещаться разные значения переменной

Есть 6 примитивных типов: string , number , boolean , symbol , null , undefined.

Ссылочный тип – это внутренний тип языка. Чтение свойства, например, с точкой .

Динами́ческая типиза́ция — приём, используемый в языках программирования и языках спецификации, при котором переменная связывается с типом в момент присваивания значения, а не в момент объявления переменной.

Создаются с помощью квадратных скобок и удаляются с помощью ключевого слово delete

Значением свойства объекта может быть всё, что угодно, включая другой объект или массив

Глобальный объект - это объект, который всегда существует в глобальной области видимости. В JavaScript всегда определён глобальный объект. В веб-браузере, когда скрипты создают глобальные переменные, они создаются как свойства глобального объекта.

Array.pop() - Удаляет последний элемент
Array.push() - Добавляет концу массива элемент
Array.reduce() - применяет функцию reducer к каждому элементу массива, возвращая одно результирующее значение. w
Array.shift() - Удаляет первый элемент
Array.slice() - возвращает новый массив, содержащий копию части исходного массива.
Array.some() - проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции
Array.sort() - сортирует элементы массива и возвращает отсортированный массив.
Array.splice() - изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.
Array.toString() - Превращает число на стринг
Array.unshift() - добавляет один или более элементов в начало массива и возвращает новую длину массива.
Array.values() - возвращает новый объект итератора массива Array Iterator, содержащий значения для каждого индекса в массиве.

Обозначение объектов JavaScript (JSON - JavaScript Object Notation) - стандартный текстовый формат для представления структурированных данных на основе синтаксиса объекта JavaScript.

Мутация в JavaScript – это изменение объекта или массива без создания новой переменной и переприсваивания значения.

22. Объявление функции (function definition, или function declaration, или function statement) состоит из ключевого слова function и следующих частей:
Имя функции.
Список параметров (принимаемых функцией) заключённых в круглые скобки () и разделённых запятыми.
Инструкции, которые будут выполнены после вызова функции, заключают в фигурные скобки { }.

23. Строки, числа, логические значения передаются в функцию по значению. Иными словами при передаче значения в функцию, эта функция получает копию данного значения.

24. Простыми словами: коллбэк — это функция, которая должна быть выполнена после того, как другая функция завершила выполнение

25. Имя функции должна быть названа смотря на задачу функции, функции должна выполнять одну задачу

Стрелочные функции отличаются от обычных не только способом записи. Главное их отличие проявляется в том, как они работают с контекстом. Вкратце: контекст обычных функций зависит от места вызова, а контекст стрелочных функций — от того места, где они были определены.

----------------------------------------------------------------------------------------------------------------
Операторы
Оператор разделения объекта на свойства (Spread syntax позволяет расширить доступные для итерации элементы)
Обработка ошибок
Массивы
Методы массивов
Метод forEach
Метод map
Условные инструкции
Цикл for
Цикл while
Цикл do while
Цикл for in
Методы keys и values для объектов
Цикл for in для массивов
Цикл for of
Модули
Правила работы с модулями
Практика по созданию нескольких экспортов
Создание экземпляров класса
Проверка принадлежности классу
Вызов унаследованных методов
constructor

1. Операторы
=== Операторы присваивания
- Присваивания с сложением
- Присваивания с вычитанием
- Присваивания с умножением
- Присваивания с делением
- Присваивания по модулью

=== Операторы сравнения
- Сравнения операндов
- Сравнения операндов и типов значений
- Сравнения не равности операндов
- Сравнения не равности оперндов и типов значени1
- Сравнения больше
- Сравнения меньше
- Сравнения больше или равно
- Сравнения меньше или равно

=== Операторы арифметического типа
- Сложение
- Вычитание
- Умножение
- Делением
- Остаток от деление
- Инкремент
- Дикремент
- Возведение в степень

=== Операторы логики
- Оператор И
- Оператор ИЛИ
- Оператор НЕ

=== Оператор строки это (+)

2. Оператор разделение Spread syntax
- Оператор spread позволяет разделять один объект или массив на разные части, она выполянется с помощью три точки.

3. Обработка ошибок
- Обратка ошибок работает при вызове конструкции try...catch, внутри блока try выполняется инструкция или функция
и в случае ошибки она код внутри catch прочтется и она вернет ошибку показывая место ошибки

4. Массив это объект содержащий в себе списководные свойства и его отличие от объектов в том что
Массивы представляют коллекции упорядоченных данных, а объекты представляют коллекции, которые не требуют данных

5. Есть очень много методов такие как map, slice, sort и тд.
map() создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.
slice() Она сокращает массив начиная с того индекса которая была написана в методо выбросив прежднее элементы
sort() Сортирует элементов в массиве

6. forEach - тоже метод массива но она считается и циклом. Она проходит по каждому элементу в массиве

7. Есть условные инструкции такие как if...else, if...else if
if...else - Она работает так что если условие правдиво то она зайдет блок внутри if,
если условие возвращает ложное то она автоматически перескакивает блок if заходя внутри else

8. for создает цикл с три 3 неважных частей, инициалиация, условие и финальное выражение
- В инициалиация создаются переменные которые будут использованы в цикле, условие это где написано логика или же как и сколько раз должна выполнятся цикл
- Внутри финального выражение будут действии

9. while цикл которая представляет бесконечные цикл, но при это если условие существует внутри цикла while
то она будет выполняться непрерывно до того как условие не возвращает false тоест ложное значение

10. do...while - это цикл похожая на обычный while цикл, различие в том что while не будет останавливать выполнение действии до того как его условие не ложное
но do...while - делает проверку каждый раз когда условие выполнится поэтому do...while сработает как минимум один раз при запуске цикла

11. for in цикл точно также работает как forEach оно тоже проходит по каждому элементу дав возможность
обратится каждому элементу внутри массива или объекта не изменив свойтсва других элементов

12. Метод keys выводит как список все ключи внутри объекта, но values выводит только значение всех имён с объекта

13. for in можно использовать для массивов но при этом есть вероятность что массив не вернет индексы на том порядке как и было.
Что избежать такие изменение рекомендуется пользоватся forEach

14. for...of выполняет цикл обхода итерируемых объектов, вызывая на каждом шаге итерации операторы для каждого значения из различных свойств объекта.

15. Модули могут загружать друг друга и использовать директивы export и import, чтобы обмениваться функциональностью, вызывать функции одного модуля из другого:

16. При использование модулей нужно либо установить package.json с типом модуль или же просто переимонавать расширение .js на .mjs
-- При экпорте одного объекта используется ключевое слово default и при импорте имя экпортированного объекта не нужно совпадать с импортированным,
но если при экспорте объекта их количества больше двух то не используется default и имя при импорте должно совпадать. Есть такие случаи в которых имя
импортированного файла уже существует в коде, то тогда нужно переименовать импортированного файла с помощью as.

17. Класс JavaScript — это вид функции. Для декларирования классов используется ключевое слово class .
Класс представляет описание объекта, его состояния и поведения, а объект является конкретным воплощением или экземпляром класса.

18. Экземпляр классов создаются с помощью функции-оператора и оператора new и создастся новый экземпляр применясь к переменному.

19. Оператор instanceof позволяет проверить, принадлежит ли объект указанному классу, с учётом наследования.

20. Наследование классов – это способ расширения одного класса другим классом. Для этого используется ключевое слово extends
Таким образом, мы можем добавить новый функционал к уже существующему.

21. Метод constructor — специальный метод, необходимый для создания и инициализации объектов,
созданных, с помощью класса. В классе может быть только один метод с именем constructor .
Исключение типа SyntaxError будет выброшено, если класс содержит более одного вхождения метода constructor .
